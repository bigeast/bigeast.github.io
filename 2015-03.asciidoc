== 2015-03-03 Tuesday 20:02:29
=== xdg-mime设置默认程序
[source, bash]
$xdg-mime default firefox.desktop x-scheme-handler/http #默认用firefox打开http链接

其实是修改了 _~/.local/share/application/mimeapps.list_ 文件

=== zsh与readline
* zsh不用readline，因此 _~/.inputrc_ 里的设置对其无效
* zle与readline有一点不同的是，kill-word这个功能的默认快捷键， 虽然都为 _M-Backspace_ 但zle对word的分界是非空白字符，/path/to/here对它来说是一个word。而readline中，会把/path/to/here当作三个单词。readline中把/path/to/here当作一个单词删除的快捷键是 _C-W_ 。

=== https://github.com/soimort/you-get[you-get]
* 下载视频网站的视频！神器！

[source, bash]
$pip3 install you-get # pip 安装
$you-get -i URL # 查看视频信息，如标题，分辨率，大小等
$you-get -F {hd2,mp4} URL # 选择某一个分辨率下载

=== rlwrap
* 不支持readline的程序，例如python，可以在前面加上 _rlwrap_ 来加上readline支持！

[source, bash]
alias python='rlwrap python'
alias maxima='rlwrap maxima'
alias guile='rlwrap guile'

* zsh不用readline，因此 _~/.inputrc_ 里的设置对其无效

* zle与readline有一点不同的是，kill-word这个功能的默认快捷键， 虽然都为 _M-Backspace_ 但zle对word的分界是非空白字符，/path/to/here对它来说是一个word。而readline中，会把/path/to/here当作三个单词。readline中把/path/to/here当作一个单词删除的快捷键是 _C-W_ 。

== 2015-03-04 Wednesday 14:57:56
=== youtube-dl
下载youtube视频，很给力的一个工具，但好像不支持国内的视频网站，不过有 _you-get_ ，是日本人写的。
[source, bash]
$youtube-dl -F URL # 列出所有可供下载的格式，每个前面有一个ID
$youtube-dl -f ID  # 下载指定格式的码流
$youtube-dl -f bestaudio URL # 下载质量最好的音频码流，下载音乐和有声读物时很有用，之前不知道，还专门找从youtube上下mp3的网站，当时就怀疑，这些网站不可能是自己下载视频后再提取音频的，不然太慢了！

== 2015-03-05 Thursday 18:54:39
=== http://en.wikipedia.org/wiki/Fabrice_Bellard[Fabric Bellard]
* 神人啊。_QEMU_ ， _ffmpeg_ 都是他写的。他还写过C编译器，整个代码只有不到4M，而且是ISO C99兼容的，编译速度比 _gcc_ 快7倍！
* 还记得刚上大学那会儿看到过有人用个人电脑破了计算pi的记录，那个人就是他。而且是基于他自己发现的公式 http://en.wikipedia.org/wiki/Bellard%27s_formula[Bellard formula] 的！他不仅知道怎么做，而且做得比别人更快更好！ （通常发明公式的应该是数学家，而数学家一般不会自己去用代码实现。）
* 前一段他还提出并实现了 http://bellard.org/bpg/[BGP] 图像编码格式，是基于HEVC的技术，对高分辨率的图像有更好的压缩效果。
* 而且他的网站非常之简洁。看得我有些惭愧。
* 或许专注一件事情才是成功之道吧！

=== xorg-xserver
* 开学后的 _pacman -Syu_ 好像更新了不该更新的东西，使得终端刷新的时候会把整个显示器搞乱。开始以为是i3wm的问题，但是回滚后还是不行。
* 想起来xrandr显示的显示器名称也变了，之前是DVI-I-1和DVI-I-2，现在成了DVI-1和DVI-2。于是把xrandr也降级，问题依然存在。
* 本来想去IRC上问一问，但是感觉这问题挺不好描述。才想起来去看Archlinux的更新公告 https://www.archlinux.org/news/xorg-server-1171-is-now-available[xorg-server 1.17.1 is now available]，然后把 _xorg-video-modesetting_ 装回来就好了。

=== http://www.w3schools.com/jsref/prop_loc_hash.asp[Location hash Property]
* 就是在URL后添加 _#section_ 来定位到html文件的某一部分的功能。wikipedia上很常见。如何在Asciidoc中实现呢？

=== http://stackoverflow.com/questions/6667201/how-to-define-two-dimensional-array-in-python[Python中的二维数组定义]
首先应该定义成列表的列表。
[source, python]
>>> arr = [[0] * 3] * 3
 [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> arr[0][0] = 1
>>> print arr
 [[1, 0, 0], [1, 0, 0], [1, 0, 0]]

明明只改了一个值，但却有三个位置的值改变了。看下它们是否是同一个对象：

[source, python]
>>> [id(x) for x in arr]
 [140692558271840, 140692558271840, 140692558271840]

但是注意
[source, python]
>>> a = [0] * 3
>>> print a
 [0, 0, 0]
>>> a[1] = 1
>>> print a
 [0, 1, 0]

当重复的对象类型是int时，就是复制了不同的实例了？其实不然，再看：
[source, python]
>>> [id(x) for x in arr]
 [23646576, 23646576, 23646576]

那既然如此，为什么改变一个值不会影响到其它三个呢？在 IRC上问了，马上得到了回答，大概是说，int类型是不可变的，你改变它，Python其实是生成了一个新的实例。而列表类型是可变的，你改变它，就会看到它的三个拷贝都变了。

那么正确的方式应该是什么呢？用列表展开！

[source, python]
>>> arr = [[ 0 for i in xrange(3)] for j in xrange(3)] 
>>> arr = [[ 0] * 3 for i in xrange(3) ] 

用一个for的列表展开更简洁，但是不那么直观，包含了一些隐式行为。

=== 单个物理屏幕的截屏
见　link:scrot.html[Scrot屏幕截图]

== 2015-03-07 Saturday 21:40:26
=== py2exe, pyinsaller
* py2exe 可以把.py程序转化成.exe程序，以在没有安装Python的Windows机器上运行，但必须在Windows中的Python中使用。:(
* pyinstaller 支持多平台，但在Linux中，还是转化成ELF可执行文件，而不是exe。所以貌似不能用它来实现交叉编译？

=== python中的排序算法
* 用的是Timsort，具体方法在源代码的Objects/listsort.txt中有描述。
* DSU模式，在Python 2.4之前，为列表指定cmp函数的一种方法。就是先将每个元素x与val(x)绑定（Decorate），然后对元组(val(x), x)进行默认的排序（Sort），最后再从排序后的元组中得到原来的元素（Undecorate）。
* 在Python 2.4中，只需要为sort传入key=cmp就行了。cmp函数还可以用lambda表达式来做。

=== 查看man page的N种方法
* 在浏览器中查看： _man -Hfirefox ls_ 有目录链接。
* 在(g)Vim中查看：_:Man ls_ 或者在关键字上按_Shift+k_ 推荐前者，有语法高亮。
* 用GNOME中的yelp： _yelp man:ls_ 只是提供了一个图形界面，并不怎么方便。

== 2015-03-08 Sunday 14:53:57
=== Vim的Syntastic插件对Python 2和Python 3的支持
* 为了能够分别对待两个不同的版本，需要使用https://github.com/scrooloose/syntastic/issues/385[virtualenv]

== 2015-03-09 Monday 10:43:16
=== zle
* kill-buffer() 与 kill-whole-line()　有什么区别？
* _M-l_ 与 _M-u_ ，down-case-word, up-case-word 将光标到行尾的字符全部变成小写或者大写。
* _M-'_ quote-line 引号括起当前行。
* _M-a_ 执行当前行，并保留到下一行。
* _M-x_ 执行命令，例如backward-delete-word之类。
* vi-backward-kill-word 会把/path/to/somewhere看作六个单词，就像readline中 _M-Backspace_ 一样。而zsh默认是把backward-kill-word绑定到 _M-Backspace_ 的。终于弄清了这个问题！现在的问题是如何在配置文件中表示 _M-Backspace_ 。目前是将其绑定到了 _C-Backspace_ 。

=== readline的一些默认快捷键移植到Vim中
* 又一个tpope的Vim插件！https://github.com/tpope/vim-rsi[vim-rsi]

=== https://github.com/tpope/vim-fugitive[vim-fugitive]
* git的Vim前端插件！

== 2015-03-11 Wednesday 16:50:23
=== Python的初始化配置
* _~/.pythonstartup_
[source, python]
import matplotlib as mpl
mpl.use('Qt5Agg')
import numpy as np
import matplotlib.pylab as plt

* matplotlib画图
	. 本来挺简单的事情，由于选择太多，反而搞得很复杂。
	. 首先python2还是python3？
	. 然后ipython2还是ipython3？
	. 用哪个图形后端？
	. _matplotlibrc_ 文件中，有 backend选项说明。
	. 一旦选定图形后端，应该是不可更改的，除非重启python shell。
	. ipython中查看当前的图形后端可以用_%matplotlib_ 命令。要想在notebook中显示图形，还需要 _%matplotlib inline_
	. 由于各种图形后端都依赖于不同的系统桌面环境，所以有时候通过pip安装matplotlib会不能显示图像。 **最好用包管理来安装**。
	. 在python shell中，plt.show()显示图像时，会阻塞shell。记得之前换了backend后就不阻塞了，跟Matlab中一样可以交互了。然而相当不稳定。**可以先执行plt.ion()**。
	. pylab库相当于 _numpy_ + _matplotlib.pyplot_ ，画简单的图形demo时， _from pylab import *_ 很方便。

[source, python]
mpl.matplotlib_fname() #显示matplotlibrc文件的位置。

[source, python]
# The default backend; one of GTK GTKAgg GTKCairo GTK3Agg GTK3Cairo
# CocoaAgg MacOSX Qt4Agg Qt5Agg TkAgg WX WXAgg Agg Cairo GDK PS PDF SVG
# Template.
# You can also deploy your own backend outside of matplotlib by
# referring to the module name (which must be in the PYTHONPATH) as
# 'module://my_backend'.
backend      : GTKAgg
# If you are using the Qt4Agg backend, you can choose here
# to use the PyQt4 bindings or the newer PySide bindings to
# the underlying Qt4 toolkit.
#backend.qt4 : PyQt4        # PyQt4 | PySide
# Note that this can be overridden by the environment variable
# QT_API used by Enthought Tool Suite (ETS); valid values are
# "pyqt" and "pyside".  The "pyqt" setting has the side effect of
# forcing the use of Version 2 API for QString and QVariant.

== 2015-03-15 Sunday 00:20:06
=== https://github.com/antiboredom/videogrep[videogrep]
通过搜索字幕文件中的单词来定位到相应的视频处，并将其输出。

== 2015-03-25 Wednesday 22:42:29
=== Firefox字体渲染
* github网站的字体总是看着很难受，像是点阵字体。设置Firefox的Latin字体，并禁止网站自己选取字体可以解决，但是系统中没有什么字体能够正确显示图标。而Chromium是可以正常显示的。原因是github默认字体是Helvetica，而Firefox对该字体是先找点阵字体的。解决方法是：

[source, bash]
ln -s /etc/fonts/conf.avail/70-no-bitmaps.conf /etc/fonts/conf.d 

== 2015-03-26 Thursday 10:03:06
=== TeX字体安装
* TeX的字体安装在 _/usr/share/texmf-dist/fonts_ 目录中，fc-list的结果中是没有的。根据https://wiki.archlinux.org/index.php/TeX_Live#Fonts[Archwiki中的方法]，需要生成几个软链接：

[source, bash]
$ ln -s /etc/fonts/conf.avail/09-texlive-fonts.conf /etc/fonts/conf.d/09-texlive-fonts.conf

=== 一些常用字体
* _Consolas_ 不多说，可是不支持汉字，_YaHei Consolas Hybrid_ 是个备选
* _Menlo_ 在自己显示器上效果不如别人的截图
* _Monaco_ 终于找到了这个字体！不过效果也不如别人截图上那么好 :o
* 官方源中的 _adobe-source-han-sans-cn-fonts_ 字体包。目前Firefox中的Latin字体就设置为这个，比YaHei Consolas Hybrid看起来还要舒服。

=== Windows命令行编译
* 有时候只有一个.c的源文件，要编译还要新建一个工程，有点麻烦。其实VS也是调用的命令行工具的。手动编译的方法如下(VS2008)：
	** 把VS安装目录（这里是 _C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC_ ）加入系统环境变量PATH中。
	** 在命令行中运行 _vcvarsall_ 。
	** 然后就可以用 _cl_ 来编译.c文件了。
[NOTE]
每次都要运行 _vcvarsall_ ，否则系统找不到 _cl_ 命令。如果要生成其它平台的代码，需要给 _vcvarsall_ 添加参数，例如要编译x64的程序，则运行 _vcvarsall x64_ 。

=== Vim命令
Vim用了这么久，还是有很多命令不知道，下面是几个我实际中经常需要用到的功能，但是有更简单的做法。
[width="50%", cols="3,7,10", options="header"]
|==================================================
| 标准方法	| 可选方法	| 功能	
| _10\|_	| 根据当前所在的位置，计算出需要移动的列数，例如当前在第3列，就可以用 _7l_ 来到达第10列 |跳到指定第10列
| y$		| vg$y		| 复制从当前位置到行尾的内容(其实更常用的是 _vg_y_ ，复制到行尾最后一个非空字符，但是好像 _y__ 命令是不存在的)
| _C-x,C-l_	| 未知		| 整行补全
| _C-a_, _C-x_ | 未知。这个很酷，但实际中用处有多大还不清楚。| 把光标所在位置处的数字增加或者减少1
|==================================================

=== .c 和 .cpp 文件的Vim Snippet
C++ 中可以写纯C，把头文件和main函数模板写成snippet，可以快速地完成代码。

snipMate插件是根据文件扩展名来识别源文件所用的语言的，例如 _cpp.snippets_ 中定义的代码块只在 _.cpp_ 和 _.cc_ 文件中起作用。但 _c.snippets_ 同样也对 C\++ 文件起作用，甚至默认的 _cpp.snippets_ 里面就没有几行，都是针对 C++ 独有的语法，共用的语法都使用 _c.snippets_ 。

=== gcc的一个bug?
C99标准支持 https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html[Designated Initializers]，就是委托初始化。例如：

[source, C]
int a[10] = {[5] = 4, [8] = 13};
int b[10] = {[2 ... 5] = 4, [8 ... 9] = 13};

编译的时候，需要指定 _-std=c99_ 参数。**而且源文件扩展名必须是.c而不是.cc**，不管你是用gcc还是g++。

所以 _gcc test.cc_ 的话，其实还是调用了 _g++_ ？

注意当要初始化的是一个数组区间的时候，点号要与数字分开，否则会被编译器认为是浮点数而报错。而且这种特性是GNU的扩展，不属于C99标准（但是-std=c99也能编译成功。）

[NOTE]
微软的编译器就是不支持C99，不能在代码中间部分定义变量，不支持for循环中定义变量。除非用C++（其实就是扩展名从 _.c_ 变成 _.cc_ ）
