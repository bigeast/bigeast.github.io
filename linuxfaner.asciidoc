== 《Linux就是这个范儿》读书笔记
2015-04-03 Friday 19:12:47

在图书馆无意中翻到的这本书，其实第一眼看完书名觉得又是一本扯淡的书，但是看印刷质量还不错，就拿来看了。

于是花了一下午读完了感兴趣的部分。

我接触和使用Linux应该5年不到，只是用它来做各种好玩儿的事情，并没有实现过大的项目，熟悉基本的命令行，软件配置，也读过好多关于Linux的书，因此书中好多部分都是一扫而过。但是有些东西确实是之前没有意识到的，感觉脑洞大开！凭借记忆举几个例子吧：

=== 关于dc, bc, m4的一节

bc我是经常使用的（现在发现gp更强大），dc也听说过，但是作者从编程语言的角度介绍dc的语法和执行规则，指出dc和bc背后，其实是一个虚拟机，这个想法有点意思。而且它们的代码都很短小，功能却很强大。m4感觉是好老的工具了，我在这本书中才知道了它是干嘛的，为什么还是很有用。

=== GNU make 一章

碰巧最近在看《GNU Make》，但不知道是不是翻译原因，感觉特别难读下去。而在这一章里，我明白了两种变量定义的区别（就是惰性求值嘛特别想说），如何在规则中写bash脚本命令（变量引用$$开头，多行要转义或者合并成一行），@+-的作用，目标专属变量（局部变量），vpath等。

后面讲autoconfig的东西就没仔细看了，作者也指出这个只是在需要跨平台的时候才适用，否则太复杂了。 

=== UDP

UDP在局域网中出现丢包的概率很小，但是大家都先入为主为了可靠性使用TCP，而放弃了速度更快的UDP。 _打破固有思维，洞见背后的真正原理_

=== diff

内部采用动态规划的方法（LCS）实现。 _也想到过，但书中这么提出来，还是觉得很有道理_

=== BPF

Berkeley Packet Filter，3.18版本才加入到内核中，提高tcpdump的过滤性能。

=== 进程与线程，以及与Windows的比较

又是这个话题。Linux是没有严格意义上的线程的，相反Windows才是基于线程调度的操作系统（原生线程）。Linux进程与线程的区别就是在fork之后COW机制的启用与否。其实Linux中如果多进程实现得好，是没有必要引入多线程的，之所以后来有了NPTL（Native POSIX Thread Library），是因为多线程在某些任务下确实有优异的表现，例如UDP传输流媒体时（不需要考虑同步问题时）。

有了NPTL之后的Linux是否就比Windows先进得多了呢（因为Windows没有真正的多进程？），不然。。注意大杀器来了。。。我们通常所说的Windows其实只是Windows的一个子系统，但Windows还有SFU（Serivce for UNIX）子系统等（OS2，PISIX貌似已经废弃了）。

Windows在DDoS攻击后恢复的能力要强于Linux。

Windows的fat32的磁盘碎片以及为什么ext2没有（很少有）碎片。其实碎片是形象的说法，假设它用来指代磁盘长时间使用后性能下降的现象。fat32性能下降是由于数据块是以单链表形势存储的，而ext2是一个inode指向所有的数据块（从图上看出来的，不确定对错）。

=== main函数的第三个参数

第三个参数指向环境变量，但标准里（C99，POSIX）是没有的，http://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable[Is char **envp as a third argument to main() portable]

=== epoll

select -> poll -> epoll

维护TCP连接是要占用系统资源的，一个TCP连接大概占8K的内存。这也是DDoS的前提。

=== putty登录Linux主机

如果用 X Forward 功能的话，需要在Windows上装一个X服务器，可选Xming，这个我之前Google过！


最后吐槽一下本书的写作风格：虽然我不是特别喜欢，但是有干货在里面，就忍了吧。不过也有些时候是赞同的，毕竟做人要有点幽默感好伐！

大概就这么多，学到了好多东西呀感觉～
