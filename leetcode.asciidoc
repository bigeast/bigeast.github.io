:source-highlighter: pygments
:pygments-style: manni

== Leetcode
* https://leetcode.com/problems/maximum-gap[Maximum Gap] *一个无序的数组，在线性时间内，找到排好序后，相邻两个元素之间差值的最大值。*
** https://leetcode.com/discuss/18487/i-solved-it-using-radix-sort[讨论区题解] 思想是，得到最大值 maxv 和最小值 minv 后，可确定最大差值的下限为 _L = (maxv - minv) / (N - 1)_ 。将[minv, maxv] 等距分割成 N - 1 段（或者更多的段，因为每段距离只要短于L，就不需要考虑段内的差值，因此对结果都不会有影响），记录每一段的最大值和最小值，最终比较某段的最小值与它前面一段的最大值之差，最大的差即为答案。 

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
int maximumGap(std::vector<int> &num) {
    for(unsigned bit = 0; bit < 31; bit++)
    std::stable_partition(num.begin(), num.end(), [bit](int a){
        return !(a & (1 << bit));
    });
    int difference = 0;
    for(std::size_t i = 1; i < num.size(); i++) {
        difference = std::max(difference, num[i] - num[i-1]);
    }
    return difference;
}
----

++++
</details>
++++

	** [red]#基数排序#

'''

* https://leetcode.com/problems/merge-two-sorted-lists[Merge Two Sorted Lists] *合并两个有序的链表。*

算法很清楚，主要是看怎么实现。如果用p指向要返回的列表当前位置，注意每次更新的时候是先改变p->next，然后p=p->next。

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
/********************************
 * Author:			bigeast
 * Time:			2015-03-14
 * Description:		AC.
 ********************************/
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
		struct ListNode res(0), *p = &res;
		while(l1 != NULL && l2 != NULL)
		{
			if(l1->val < l2->val)
			{
				p->next = l1;
				l1 = l1->next;
			}
			else
			{
				p->next = l2;
				l2 = l2->next;
			}
			p = p->next;
		}
		if(l1 == NULL)
		{
			p ->next = l2;
		}
		else if(l2 == NULL)
		{
			p ->next = l1;
		}
		return res.next;
    }
};
----

++++
</details>
++++

'''

* https://leetcode.com/problems/search-for-a-range[Search for a range] 

**有序数组里的 lower_bound 和 upper_bound**

[line-through]#突然发现自己好像还不会这个。想了一下也没想出来，应该是二分查找稍微变形一下#

盯着代码看，就想出来了。找上下界与一般二分查找的不同之处是，在找到目标元素后是否还继续寻找。

++++
<details>
<summary>
代码
</summary>
++++

[source, C++]
-----
class Solution {
	public:
		int lower_bound(int A[], int n, int target)
		{
			int lo = 0, hi = n - 1, mid;
			while(lo <= hi)
			{
				mid = lo + (hi - lo)/2;
				if(A[mid] == target)
				{
					if(mid == 0 || A[mid - 1] < A[mid])
					{
						return mid;
					}
					else
					{
						hi = mid - 1;
					}
				}
				else if(A[mid] > target)
				{
					hi = mid - 1;
				}
				else
				{
					lo = mid + 1;
				}
			}
			return -1;
		}
		int upper_bound(int A[], int n, int target)
		{
			int lo = 0, hi = n - 1, mid;
			while(lo <= hi)
			{
				mid = lo + (hi - lo)/2;
				if(A[mid] == target)
				{
					if(mid == n - 1 || A[mid + 1] > A[mid])
					{
						return mid;
					}
					else
					{
						lo = mid + 1;
					}
				}
				else if(A[mid] > target)
				{
					hi = mid - 1;
				}
				else
				{
					lo = mid + 1;
				}
			}
			return -1;
		}
		vector<int> searchRange(int A[], int n, int target) {
			vector<int> range;
			range.push_back(lower_bound(A, n, target));
			range.push_back(upper_bound(A, n, target));
			return range;
		}
};
-----

++++
</details>
++++

'''
'''

=== 链表操作
* https://leetcode.com/problems/reverse-linked-list-ii/[reverse-linked-list-ii]

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
/**************************************************
* Time: Sat 26 Sep 2015 05:31:40 PM CST
* Author: Bigeast
* Descriptions: 想好，就能写对
* Status: AC
**************************************************/

class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if(m >= n) return head;
        ListNode ahead(0);
        ahead.next = head;
        stack<ListNode *> stk;
        ListNode *ap = &ahead, *p;
        int i;
        for(i = 1; i < m && p; ++i) {
            ap = ap->next;
        }
        p = ap;
        for(; i <= n && p; ++i) {
            p = p->next;
            stk.push(p);
        }
        if(p) { // n is not larger than length.
            ListNode *btail = p->next;
            while(!stk.empty()) {
                ap->next = stk.top();
                stk.pop();
                ap = ap->next;
            }
            ap->next = btail;
        }
        return ahead.next;
    }
};
----

++++
</details>
++++


'''

* https://leetcode.com/problems/swap-nodes-in-pairs/[swap-nodes-in-pairs]

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
class Solution {
	public:
		ListNode* swapPairs(ListNode* head) {
			ListNode *p1, *p2, *tmp;
			p1 = head;
			if(p1)p2 = p1->next;
			else return p1;
			if(p2)
			{
				tmp = p2->next;
				p2->next = p1;
				p1->next = swapPairs(tmp);
				return p2;
			}
			else return p1;
		}
};
----

++++
</details>
++++


'''

* https://leetcode.com/problems/reverse-nodes-in-k-group/[reverse-nodes-in-k-group]
	** 自己的代码写得有点丑。
	** 顺便看下Java中节点的定义：


++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode curr = head;
    int count = 0;
    while (curr != null && count != k) { // find the k+1 node
        curr = curr.next;
        count++;
    }
    if (count == k) { // if k+1 node is found
        curr = reverseKGroup(curr, k); // reverse list with k+1 node as head
        // head - head-pointer to direct part, 
        // curr - head-pointer to reversed part;
        while (count-- > 0) { // reverse current k-group: 
            ListNode tmp = head.next; // tmp - next head in direct part
            head.next = curr; // preappending "direct" head to the reversed list 
            curr = head; // move head of reversed part to a new node
            head = tmp; // move "direct" head to the next node in direct part
        }
        head = curr;
    }
    return head;
}
----

++++
</details>
++++


++++
<details>
<summary>
ListNode
</summary>
++++

[source, Java, numbered]
----
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
----

++++
</details>
++++

'''

* https://leetcode.com/problems/intersection-of-two-linked-lists/[intersection-of-two-linked-lists]
	** 找到两个链表开始相交的地方。
	** 方法就是先算出两个链表的长度，然后长的先走一点，与短的对齐，之后两个链表同步，如果有相交，这样一定会碰上。
	** [red]#有一点技巧就是，有时不能确定两个数组的长短，但是代码中又需要用到他们的长短关系，这时可以做一次判断，如果长短关系不满足假设，则交换参数的位置多调用一次。#
	
++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
class Solution {
public:
    int listLength(ListNode *root) {
        int res = 0;
        while(root) {
            res++;
            root = root->next;
        }
        return res;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int m = listLength(headA), n = listLength(headB);
        if(m < n) return getIntersectionNode(headB, headA);
        ListNode *pA = headA, *pB = headB;
        for(int i = 0; i < m - n; ++i) {
            pA = pA->next;
        }
        while(pA != pB) {
            pA = pA->next;
            pB = pB->next;
        }
        return pA;
    }
};
----

++++
</details>
++++
	

=== 连续整数
* https://leetcode.com/problems/first-missing-positive/[first-missing-positive]
	** 题目中要求是线性时间，常数空间。如果空间没有要求，可以使用桶排序类似的方法。
	** 交换次数是线性的。
	** 然而实际的运行时间并没有降低。。

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 1;
        for(int i = 0; i < n; ++i) {
			// 遇到一个元素就把它放到正确的位置。
            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { // 继续为新换到i位置的元素找到合适的位置。
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for(int i = 0; i < n; ++i) {
			if(nums[i] != i + 1) {
				return i + 1;
			}
        }
        return n + 1;
    }
};
----

++++
</details>
++++

'''

* https://leetcode.com/problems/longest-consecutive-sequence/[longest-consecutive-sequence]
	** 用哈希表存储元素，方便查找元素是否存在。 `C++` 中使用 `unordered_map` 代替哈希表。
	** 对与每个元素，向前和向后查找相邻的元素是否存在，若存在则从哈希表中删除（避免重复查找）。

'''
'''

=== next_permutation
* https://leetcode.com/problems/next-permutation/[next-permutation]
	** STL中现成函数 *next_permutation*
	** [line-through]#手动实现时，额，方法又忘了。#
	** 步骤是：
		*** 找到最后一段不增序列，设为[i, n - 1]
		*** 在[i, n - 1]中找到最小的比 nums[i - 1] 大的一个数 nums[j]。
		*** `swap(num[i - 1], num[j]);`
		*** 对新的[i, n - 1]区间进行排序。
	** 关键是查找nums[j]时，如何用二分方法？upper_bound貌似不能直接用！自己实现又容易出错。 [red]#在数组递减排序时如何使用lower_bound和upper_bound呢？#
++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
class Solution {
	public:
		void nextPermutation(vector<int> &num) {
			int i, j;
			for(i = num.size() - 1; i > 0 && num[i - 1] >= num[i]; --i);
			if(i > 0) {
				for(j = num.size() - 1; j > i && num[j] <= num[i - 1]; --j);
				swap(num[i - 1], num[j]);
			}
			sort(num.begin() + i, num.end());
		}
};
----

++++
</details>
++++

'''

=== 两个有序数组的中值
* https://leetcode.com/problems/median-of-two-sorted-arrays/[median-of-two-sorted-arrays]
	** 需要有一种比较巧妙的方法来实现，不然会很麻烦。
	** 假设两个数组 nums1 和 nums2 的长度分别是 m, n，且 m <= n，则算法复杂度是 `O(log m)`
	** 当 `m + n` 为奇数时，中位数下标是 `(m + n + 1) / 2` ；当 `m + n` 为偶数时，中位数为 `(m + n + 1) / 2` 与 `(m + n + 1) / 2 + 1` 的均值。
	** 将两个数组都分成两个部分，最终的中位数是由两个分界处的四个元素决定的。
	** 例如设 nums1[0 ... i - 1] 为nums1的第一部分，nums2[0 ... j - 1] 为nums2的第一部分。则 `m + n` 为奇数时，如果 `max{nums1[i - 1], nums2[j - 1]}` 是中位数，充要条件是 `i + j = (m + n + 1) / 2` ，且 `max{nums1[i - 1], nums2[j - 1]} < min{nums1[i], nums2[j]}` 。
	** 边界条件好容易出错！！这个太难写对了。
	** http://articles.leetcode.com/2011/01/find-k-th-smallest-element-in-union-of.html[答案说明]
	** 还有一种做法是用两个index分别指向两个数组，每次增加数值小的那个，复杂度O(k)。其实就是模拟归并排序。

++++
<details>
<summary>
代码
</summary>
++++

[source, C++, numbered]
----
class Solution {
	public:
		double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
			int m = nums1.size(), n = nums2.size();
			if(m > n) return findMedianSortedArrays(nums2, nums1);
			//int lo = 0, hi = m - 1;
			int lo = 0, hi = m;
			int i, j; // i, j 分别代表 nums1 和 nums2 在合成数组中的前一半中所占的元素个数，注意不是下标！
			double res1 = 0, res2 = 0, res;
			while(lo <= hi) {
				i = lo + (hi - lo) / 2;
				j = (m + n + 1) / 2 - i;
				if(i > 0 && j < n && nums1[i - 1] > nums2[j]) // nums2 小了，需要减少 nums1 的长度使它增大。
					hi = i - 1;
				else if(j > 0 && i < m && nums2[j - 1] > nums1[i]) // nums1 小了，需要增大。
					lo = i + 1;
				else {
					if(i == 0) {
						res1 = nums2[j - 1];
					}
					else if(j == 0) {
						res1 = nums1[i - 1];
					}
					else {
						res1 = max(nums1[i - 1], nums2[j - 1]);
					}
					if((m + n) % 2 == 0) {
						if(i == m)
							res2 = nums2[j];
						else if(j == n)
							res2 = nums1[i];
						else
							res2 = min(nums1[i], nums2[j]);
					}
					break;
				}
			}
			res = ((m + n) & 1) ? res1 : (res1 + res2) / 2.0;
			return res;
		}
};
----

++++
</details>
++++



'''

=== 子集和DFS
* https://leetcode.com/problems/two-sum/[two-sum]

'''

* https://leetcode.com/problems/3sum/[3sum]

'''
* https://leetcode.com/problems/4sum/[4sum]

'''
* https://leetcode.com/problems/generate-parentheses/[generate-parentheses]

'''
* https://leetcode.com/problems/palindrome-partitioning/[palindrome-partitioning]

'''
=== DP
* https://leetcode.com/problems/longest-palindromic-substring/[longest-palindromic-substring]

'''
=== 其它
* https://leetcode.com/problems/palindrome-number/[palindrome-number] *判断是否是回文数字，不能使用额外的空间。*


* https://leetcode.com/problems/largest-rectangle-in-histogram/[largest-rectangle-in-histogram] [red]#*直方图所包含的最大矩形*#

++++
<details>
<summary>
O(n^2)的算法,TLE
</summary>
++++

[source, C++, numbered]
----
class Solution {
public:
    int largestRectangleArea(vector<int>& height) {
        int n = height.size();
        set<int> S;
        for(int i = 0; i < n; ++i) {
            S.insert(height[i]);
        }
        int res = 0;
        for(auto item: S) {
            int area = 0;
            int span, idx = 0;
            while(idx < n) {
                span = 0;
                while(item <= height[idx++]) {
                    ++span;
                }
                if(span * item > res) res = span * item;
            }
        }
        return res;
    }
};
----

++++
</details>
++++

'''

:docinfo:
