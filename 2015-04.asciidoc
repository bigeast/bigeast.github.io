== 2015-04-02 Thursday 23:16:18
=== 自动给文件的某个pattern前加上某段文本
在cnzz.com上注册了个帐号，想统计一下这个博客的访问流量。需要给每个html文件加上一段代码，肯定不能手动呀，首先想到用 _sed_ ：

[source, bash]
$ sed -i '/regexpattern/ i text' index.html

然后希望写到makefile中，每次生成完html文件后就执行这条sed命令。但是不知道怎么在makefile里跨行执行shell代码。于是退而求其次，写到了一个外部脚本里，然后在makefile的all规则中加上这个脚本的名字。还有如果要插入的文本是在另一个文件中，需要：

[source, bash]
$ sed -i '/regexpattern/ r text.txt' index.html

=== 命令行自动登录校园网
最开始尝试了用 _curl -F_ 做表单提交，但是没有成功。网上搜到了说用 Firefox 的 Firebug 和 Firecurl 插件，可以得到每一步对应的curl命令。然后到 Firecurl 的下载页面又说：_don't use this -- use Chrome Developer Tools' "Copy as cURL", which is much more complete_

可是最终这种方法的到的curl命令也不能成功登录。

继续Google，找到了github上有人三年前写的https://github.com/tianyang-li/TUNET[Python脚本]，挺简单的，没有用表单提交，直接跟cgi交互。

于是写了个 shell 版的。。
[source, bash]
#!/bin/bash
case "$1" in
	login)
		username=${2:wdd13}
		password=$(echo -n $3 | md5sum | cut -d' ' -f1)
		curl -d "username=${username}&password=${password}&drop=0&type=1&n=100" http://net.tsinghua.edu.cn/cgi-bin/do_login
		;;
	logout)
		curl http://net.tsinghua.edu.cn/cgi-bin/do_logout
		;;
	*)
		curl -d 'action=check_online' http://net.tsinghua.edu.cn/cgi-bin/do_login                                  
		;;
esac

== 2015-04-04 Saturday 19:58:45
=== HTTP2
* https://http2.github.io[官方博客]
* https handshake
* http/2和SPDY协议传的是二进制的，而http/1.1传的是文本。快速。
* TLS everywhere
* http/1.1是应用层协议，而http/2是会话层和应用层协议，不是完全替代1.1，而是进行了扩展。
* HPACK
	* http/2的header压缩协议
	* 没有前缀匹配，（为了安全）
	* 名称和值对于算法来说是不透明的
	* 编码端决定哪一部分被压缩
	* 静态表，动态表，huffman
	* 不选用gzip是为了防止 _CRIME_ 。**CRIME会引诱浏览器把不同的文本内容发给目标网站，观察压缩后的header变化，如果对于某个特定的内容，header变小了，说明注入的内容中有与用户的cookies相同的部分，据此来推测出用户的cookie，劫持用户的会话。**
* 一些边界情况
	* 处理大的header
	* 作为http/1.1的代理
* 负载均衡时的优势。
* Server push。预测用户的需要，在client发出请求前就做出回应。
* 减少了TCP连接，使服务器能够处理更多的并发。
* **FAQ上的问题**
	** http/1.1的问题是，一个http请求会导致多个TCP连接同时发送请求。
	** 与十几年前相比，现在的网页包含了更多的内容，例如js脚本，css信息，多媒体资源，而现在的http/1.1只能允许TCP一次发出一个资源请求。
	** 以SPDY为基础。
	** http/1.1中，浏览器会为每个来源网站建立四到八个连接，如果一个网站包含多个来源，连接可能会更多，这些连接容易触发TCP的拥塞控制和重传。http/2只需要一个连接。
	** 关于server push，目前的情况是，客户端先收到html文档，解析后，如果其中有嵌入的JS脚本或者CSS样式，则再次发出请求。

== 2015-04-11 Saturday 15:23:15
=== php简单运行
[source, php]
<?php
$input = $_GET["param"];
echo "<div>".$input."</div>"
?>

存为a.php，然后进入到该目录下，运行 `php -S localhost:8000` ，然后在浏览器中输入 `localhost:8000/a.php?param=Hello PHP`
`localhost:8000/a.php?param=<script>alert(/xss/)<script>`

=== Cookies
`Ctrl+Shift+i` 调出浏览器的控制台，然后可以执行JavaScript脚本，例如查看当前的页面的Cookie： _document.cookie_
* 修改document.cookie
	** document.cookie是一个string，以分号隔开的 _key=value_ 值对。直接给它赋值并不会覆盖掉之前的值，而是添加到原来值之后。例如cookie里本来有一个 _name=bigeast_ 的值，想要删除或者修改它，需要知道Set-Cookie时，它的一些属性信息，例如domain, path等，这些信息在document.cookie中是看不到的，但可以通过调试窗口找到。要删除一个cookie，只需设置好正确的domain, path, 然后把它的expires值设成过去的一个时间就可以了。

[source, javascript]
document.cookie = "name=whatever; domain=.google.com; path=/; expires=Thu, 2 Aug 2001 20:47:11 UTC;"

Set-Cookie时如果加上HttpOnly字段，则该cookie不能被JavaScript读取。
